
[[code/go]]

特性
	编译生成一个静态执行文件，只依赖[[glibc]]
	并发性好

gofmt -w yourcode.go

go是静态类型的语言

虽然我们希望C++程序员意识到Go是个较好的选择，但是令人意外的是，大多数Go程序员来自Python和Ruby这样的动态语言，而很少有来自C++的。

将语言和今日的硬件绑在一起似乎有点目光短浅并且不明智，因为硬件过几年就有大变。

无论任何时候，你都不应该将一个控制结构（(if、for、switch或select）的左大括号放在下一行。如果这样做，将会在大括号的前方插入一个分号，这可能导致出现不想要的结果。

memory 
	new 它返回了一个指向新分配的类型为T的零值的指针。

function 
	Go中很多Package 都会返回两个值，一个是正常值，一个是错误

Go语言中没有public, protected, private的关键字，所以，如果你想让一个方法可以被别的包访问的话，你需要把这个方法的第一个字母大写。这是一种约定。

一个对于C和C++的Go的重要的简化的列表:

常规的语法(不需要一个符号表来辅助解析)
GC机制(仅仅是GC)
没有头文件
显式依赖关系
没有循环依赖
数字常量仅仅是数字(译者: 没有类型)
int和int32不是同种类型
字母大小写将确定可见性
# 任何类型都可以有方法(没有类)
# 没有子类型继承(没有子类)
包级别的初始化和良好定义的初始化顺序
同一个包的文件一起编译
包级别的全局定义可以以任意顺序进行
没有算术类型转换(常量可以弥补)
接口是隐式实现的(没有”implements”声明)
嵌入的结构体(没有类型提升和子类)
方法像函数一样定义(不必定义在特殊的地方)
方法就是函数
接口就是方法(没有数据)
方法仅仅靠名字匹配(不是靠类型)
没有构造函数和析构函数
后置增量/减量运算符仅仅是语句，而不是表达式
没有前置增量/减量运算符
赋值号是语句，不是表达式
表达式求值顺序在赋值和函数调用时确定(没有所谓的”sequence point”)
没有指针算术
内存总是初始化为0
对本地变量取地址是合法的
方法中没有叫this的指针
分段式栈
没有常量或其它类型的注记
没有模板
没有异常
内建字符串，切片和映射(map)
数组边界检查

