
GoF的23个设计模式

好了，回到我的论点――“GoF的这23个设计模式和OO关系不大，并且和Unix的设计思想基本一致，只不过GoF用OO实现了它们”，

让我们来看看这23个经典的设计模式中的几个常用的模式：

Factory.Method 模式，
	编程中，像内存池，线程池，连接池等池化技术都是这个模式，
	当然，Factory给你的一个对象，而不单单只是资源，factory创建出来的对象都有同样的接口可以被多态调用。
	# 这其实和Unix把所有的硬件都factory成文件一样，并提供了read/write等文件操作来让你操作任意设备的I/O。
	

Abstract.Factory：抽象工厂这个模式是创建一组有同一主题的不同的类。
	这个模式在现实社会当中也有很多例子，比如： 
	移动公司的合约机计划，88套餐（通话100分钟，短信100条，彩信，20条，上网200M），128套餐（通话200分钟，短信150条，彩信50条，上网500M）……
	家里的装修，总是要有厨卫，有门，有灯，有沙发，有茶几，有床，有衣柜，有电视，有冰箱，有洗衣机……，这些都是必需的，只是每个家庭里的具体装修不一样。
	Diablo游戏中的Normal，Hard，Nightmare，Hell模式，这些模式的怪和场景和故事情况都差不多，就是每个场景的怪物和装备的属性不一样。
	或是WarCraft中的地图就是一个Abstract Factory模式(注：Warcraft的地图什么都能干)。
	这和学校中的小学，初中，高中，大学差不多，都是一样的学习环境，一样的教学方式，一样的教室，都要期中考和期末考，都有班长和科代表，就是学的东西的难度不一样，但基本上都是语文，英语，数，理，化，还有永远都有的政治课。
	学校就是一个抽象工厂。
	
	在Unix下，抽象工厂这个模式在Unix下就像是/etc/rcX.d下的那些东西，1代表命令行单用户，2，代表命令行多用户，3代表命令行多用户完整模式启动，5代表图形界面启动，0代表关机，6代表重启，你要切换的话，init <X>就行了。
	

Prototype模式，原型模式，复制一个类的实现。
	传真，复印，都是这个模式。
	Unix进程和Github项目的Fork就是一种。
	进程fork明显不是OO的模型
	

Singleton模式，单例模式。
	生活中，公司只有一个CEO，
	法律限制你只能有一个老婆，
	你只能有一个身份证号，
	一个TCP端口只能被一个进程使用
	Unix下实现单例进程的一个最常用的实践是在进程启动的时候用“(S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)”模式打开一个“锁文件”。
	

Adapter模式，适配器模式。
	可以兼容欧洲美国中国的插头或插座，万能读卡器，
	可以播放各种格式多媒体文件的插放器，
	可以解析FTP/HTTP/HTTPS/等网络协议的浏览器，
	可以兼容各大银行的银联接口、支付宝、Paypal、VISA等银行接口，可以适配各种后端的解释器的Nginx或Apache，
	用非OO的编程方式就是重新包装成一个标准接口。
	这个模式很像Unix下的/dev下的那些文件，操作系统把系统设备适配成文件，于是你就可以使用read/write来进行读写了。
	

Bridge模式，桥接模式。
	一个灯具可以接各种灯泡或灯管，
	一个电钻可以换上不同的钻头来适应不同的材料，
	一辆汽车可以随时更换不同的轮胎来适应不同的路面，
	你的桌面可以随时更换一个图片来适应你的心情，
	你的单反相机可以更换不同的镜头来拍不同的照片…… 
	桥接模式说白了就是组件化，模块化，可以自由拼装。
	在OO中，其主要是通过让业务类组合一个标准接口来完成，这在非OO的程序设计中，主要是通过回调函数或是标准接口来实现。
	这个也是Unix设计哲学中的主要思想。
	在Unix中，文件的权限使用的就是Bridge模式，标准接口是用户，用户组和其它，rwx三个模式，然后用 chmod/chown改一改，这文件就有不同的属主和属性了。

Decorator模式，装饰模式。
	给手机或电脑贴个什么，挂个什么，吃东西的时候加点什么佐料，多点肉还是多个蛋，
	一个Unix/Linux命令的各种参数是对这个命令的修饰，等等。
	我觉得这个模式在Unix中最经常的体现就是通过管道把命令连接起来来完成一个功能，ps -elf  是列进程的，用管道 grep hchen就可以达到过滤的目的，grep的逻辑没有侵入ps中，grep 修饰了 ps，但是其组合起来完成了一个特定的功能。

Facade模式，
	这个模式就是把一大堆类拼装起来，并统一往外提供提口。
	旅行社把机票，酒店，景点，导游，司机，进店打了一个包叫旅行；
	IBM把主机，存储，OS，J2EE，DB，网络，流程打了个包叫企业级解决方案。
	Unix中最典型的一个例子就是用Shell脚本组合各种命令来创造一个新的功能，这是的Shell中的各种命令通过标准I/O这个接口进行组合交互。
	

Proxy模式，代理模式。
	租个房，买个机票，打个官司，都少不了代理，人大代表代理了老百姓去行使政治权力。
	我们去饭馆里吃饭也是一种代理模式，因为我们只管吃就好了，洗菜做饭洗碗的工作都被Proxy帮你干了，于是你就省事多了。
	操作系统就是硬件的代理，CDN就是网站的代理，
	让事情变理更简单，也可以在代理层加入一些权限检查，这样可以让业务模块更关注业务，而把一些非业务的事情剥离出来交给代理以完成解耦。
	Unix下这个模式最佳体现就是Shell，它代理了系统调用并提供UI。
	还有很多命令会帮你把/proc目录下的那些文件内容整理和显示出来。

Chain of Responsibility模式，
	劫匪来抢银行，保安搞不定，就交给110，110搞不定就交给武警。
	这个思想很像编程中的异常处理机制，一层一层地往上传递异常直到异常被捕捉。
	在Unix下，一个最简单的例子就是用 && 或 || 来把命令拼起来，如：cmd1 && cmd2  或 cmd3 || cmd4 ， 如果cmd1失败了，cmd2就不会执行，如果cmd3失败了，cmd4才会执行。

Command模式，
	编辑器里的Undo/Redo，宏录制。
	还有数据库的事务处理，线程池，设置向导，包括程序并行执行的指令集等等。
	这个模式主要是把一个对象的行为封装成一个一个的有相同接口的command，然后交给一个统一的命令执行器执行或管理这些命令。
	这个模式和我们的Unix/Linux机器启动时在/etc/init.d下的那些S和K开头的脚本很像，把各种daemon的启动和退出行为封装成一个脚本其支持reload/start/stop/status这样的命令，然后把他们按一定的规范做符号链接到/etc/init.d目录下，这样操作系统就会接管这些daemon的启动和退出。
	

[[Observer模式]]，观察者模式，这个模式也叫pub-sub模式，
	微博的follow的信息流	
	MVC中的C会sub V中的事件，用非OO的方式其实也是一个回调函数的事。
	在很多异步系统中，你需要知道最终的调用有没有成功，比如说调用支付宝的支付接口，你需要向支付宝注册一个回调的接口，以便支付宝回调你。
	Linux下的一些系统调用如epoll/aio/inotify/signal都是这种思路。
	

Strategy 模式，策略模式，这个模式和Bridge模式很像，只不过Bridge是结构模式，其主要是用于对象的构造；而Strategy是行为模式，主要是用于对象的行为。
	浏览器里的各种插件，只要你装了某个插件，你就有某个功能。
	

Bridge 和 Strategy是OO设计模式里的“Favor Composition Over Inheritance” 的典范，其实现了接口与实现分离的。
	Unix中的Shell就是一种，你可随意地更换不同的Shell。
	还有Emacs中的LISP驱动C，C实现了引擎，交给LISP实现逻辑。
	把程序分为前端和后端，通过socket专用应用协议进行通讯，前端实现策略，后端实现机制。
	makefile把编译器和源代码的解耦，
	命令行输出这个接口可以把一个复杂的功能解耦并抽像成各种各样小而美的小功能命令
	

